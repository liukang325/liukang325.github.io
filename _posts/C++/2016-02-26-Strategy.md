---
layout: post
title: Strategy模式
category: C＋＋
tags: 设计模式
keywords: 
description: 
---

Strategy 模式和 Template 模式要解决的问题是相同（类似）的，都是为了给业务逻辑（算法）具体实现和抽象接口之间的解耦。Strategy 模式将逻辑（算法）封装到一个类（Context）里面，通过组合的方式将具体算法的实现在组合对象中实现，再通过委托的方式将抽象接口的实现委托给组合对象实现。

Context.h

```
#ifndef _CONTEXT_H_
#define _CONTEXT_H_
class Strategy;
/**
*这个类是 Strategy 模式的关键，也是 Strategy 模式和 Template 模式的根本区别所在。
*Strategy 通过“组合”（委托）方式实现算法 （实现）的异构，而 Template 模式则采取的 是继承的方式
*这两个模式的区别也是继承和组合两种实 现接口重用的方式的区别
*/

class Context {
public:
    Context(Strategy* stg);
    ~Context();
    void DoAction();
protected:
private:
    Strategy* _stg;
};
#endif //~_CONTEXT_H_

```

Context.cpp

```
#include "Context.h"
#include "Strategy.h"
#include <iostream>
using namespace std;
Context::Context(Strategy* stg)
{
    _stg = stg;
}

Context::~Context()
{
    if (!_stg)
        delete _stg;
}

void Context::DoAction()
{
    _stg->AlgrithmInterface();
}


```

Strategy.h

```
#ifndef _STRATEGY_H_
#define _STRATEGY_H_
class Strategy {
public:
    Strategy();
    virtual ~Strategy();
    virtual void AlgrithmInterface() = 0;
protected:
private:
};

class ConcreteStrategyA:public Strategy {
public:
    ConcreteStrategyA();
    virtual ~ConcreteStrategyA();
    void AlgrithmInterface();
protected:
private:
};
class ConcreteStrategyB:public Strategy {
public:
    ConcreteStrategyB();
    virtual ~ConcreteStrategyB();
    void AlgrithmInterface();
protected:
private:
};
#endif //~_STRATEGY_H_

```

Strategy.cpp

```
#include "Strategy.h"
#include <iostream>
using namespace std;
Strategy::Strategy() { }
Strategy::~Strategy()
{
    cout<<"~Strategy....."<<endl;
}
void Strategy::AlgrithmInterface()
{
}

ConcreteStrategyA::ConcreteStrategyA()
{
}
ConcreteStrategyA::~ConcreteStrategyA()
{
    cout<<"~ConcreteStrategyA....."<<endl;
}
void ConcreteStrategyA::AlgrithmInterface()
{
    cout<<"test ConcreteStrategyA....."<<endl;
}

ConcreteStrategyB::ConcreteStrategyB()
{
}
ConcreteStrategyB::~ConcreteStrategyB() {
    cout<<"~ConcreteStrategyB....."<<endl;
}
void ConcreteStrategyB::AlgrithmInterface()
{
    cout<<"test ConcreteStrategyB....."<<endl;
}

```

main.cpp

```
#include "Context.h"
#include "Strategy.h"
#include <iostream>
using namespace std;
int main(int argc,char* argv[])
{
    Strategy* ps;
    ps = new ConcreteStrategyA();
    Context* pc = new Context(ps);
    pc->DoAction();
    if (NULL != pc)
        delete pc;
    return 0;
}

```

可以看到 Strategy 模式和 Template 模式解决了类似的问题，也正如在 Template 模式中分析的，Strategy 模式和 Template 模式实际是实现一个抽象接口的两种方式：继承和组合之间的区别。要实现一个抽象接口，继承是一种方式：我们将抽象接口声明在基类中，将具体的实现放在具体子类中。组合（委托）是另外一种方式：我们将接口的实现放在被组合对象中，将抽象接口放在组合类中。

在面向对象的设计中的有一条很重要的原则就是：优先使用（对象）组合，而非（类）继承（Favor Composition Over Inheritance）
