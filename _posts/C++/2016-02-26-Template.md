---
layout: post
title: Template模式
category: C＋＋
tags: 设计模式
keywords: 
description: 
---

在面向对象系统的分析与设计过程中经常会遇到这样一种情况：对于某一个业务逻辑（算法实现）在不同的对象中有不同的细节实现，但是逻辑（算法）的框架（或通用的应用算法）是相同的。Template 提供了这种情况的一个实现框架。 

```
//Template.h
#ifndef _TEMPLATE_H_
#define _TEMPLATE_H_
class AbstractClass {
public:
    virtual ~AbstractClass();
    void TemplateMethod();
protected:
    virtual void PrimitiveOperation1() = 0;
    virtual void PrimitiveOperation2() = 0;
    AbstractClass();
private:
};

class ConcreteClass1:public AbstractClass {
public:
    ConcreteClass1();
    ~ConcreteClass1();
protected:
    void PrimitiveOperation1();
    void PrimitiveOperation2();
private:
};

class ConcreteClass2:public AbstractClass {
public:
    ConcreteClass2();
    ~ConcreteClass2();
protected:
    void PrimitiveOperation1();
    void PrimitiveOperation2();
private:
};
#endif //~ TEMPLATE H

```

```
#include "Template.h"
#include <iostream>
using namespace std;
AbstractClass::AbstractClass() { }
AbstractClass::~AbstractClass() { }
void AbstractClass::TemplateMethod()
{
    //将通用算法（逻辑）封装起来
    this->PrimitiveOperation1();
    this->PrimitiveOperation2();
}

ConcreteClass1::ConcreteClass1() { }
ConcreteClass1::~ConcreteClass1() { }
void ConcreteClass1::PrimitiveOperation1()
{
    //将算法细节让子类实现（多态）
    cout<<"ConcreteClass1...PrimitiveOperat ion1"<<endl;
}
void ConcreteClass1::PrimitiveOperation2()
{
    //将算法细节让子类实现（多态）
    cout<<"ConcreteClass1...PrimitiveOperat ion2"<<endl;
}

ConcreteClass2::ConcreteClass2() { }
ConcreteClass2::~ConcreteClass2() { }
void ConcreteClass2::PrimitiveOperation1()
{
    cout<<"ConcreteClass2...PrimitiveOperat ion1"<<endl;
}
void ConcreteClass2::PrimitiveOperation2()
{
    cout<<"ConcreteClass2...PrimitiveOperat ion2"<<endl;
}

```

```
#include "Template.h"
#include <iostream>
using namespace std;
int main(int argc,char* argv[])
{
    AbstractClass* p1 = new ConcreteClass1();
    AbstractClass* p2 = new ConcreteClass2();
    p1->TemplateMethod();
    p2->TemplateMethod();
    return 0;
}

```

Template 模式是很简单模式，但是也应用很广的模式。如上面的分析和实现中阐明的Template 是采用继承的方式实现算法的异构，其关键点就是将通用算法封装在抽象基类中，并将不同的算法细节放到子类中实现。 

Template 模式暴露的问题也正是继承所固有的问题，Strategy 模式则通过组合（委托）来达到和 Template 模式类似的效果，其代价就是空间和时间上的代价，关于 Strategy 模式的详细讨论请参考 Strategy 模式解析。 
