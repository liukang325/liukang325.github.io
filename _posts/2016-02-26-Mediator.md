---
layout: post
title: Mediator模式
category: C++
tags: 设计模式
keywords: 
description: 
---

在面向对象系统的设计和开发过程中，对象之间的交互和通信是为常见的情况，因为对象间的交互本身就是一种通信。在系统比较小的时候，可能对象间的通信不是很多、对象也比较少，我们可以直接硬编码到各个对象的方法中。但是当系统规模变大，对象的量变引起系统复杂度的急剧增加，对象间的通信也变得越来越复杂，这时候我们就要提供一个专门处理对象间交互和通信的类，这个中介者就是 Mediator 模式。Mediator 模式提供将对象间的交互和通讯封装在一个类中，各个对象间的通信不必显势去声明和引用，大大降低了系统的复杂性能（了解一个对象总比深入熟悉 n 个对象要好）。

Colleage.h

```c++
#ifndef _COLLEAGE_H_
#define _COLLEAGE_H_
#include <string>
using namespace std;
class Mediator;
class Colleage {
public:
    virtual ~Colleage();
    virtual void Aciton() = 0;
    virtual void SetState(const string& sdt) = 0;
    virtual string GetState() = 0;
protected:
    Colleage();
    Colleage(Mediator* mdt);
    Mediator* _mdt;
private:
};

class ConcreteColleageA:public Colleage {
public:
    ConcreteColleageA();
    ConcreteColleageA(Mediator* mdt);
    ~ConcreteColleageA();
    void Aciton();
    void SetState(const string& sdt);
    string GetState();
protected:
private:
    string _sdt;
};

class ConcreteColleageB:public Colleage {
public:
    ConcreteColleageB();
    ConcreteColleageB(Mediator* mdt);
    ~ConcreteColleageB();
    void Aciton();
    void SetState(const string& sdt);
    string GetState();
protected:
private:
    string _sdt;
};
#endif //~_COLLEAGE_H_
```

Colleage.cpp

```c++
//Colleage.cpp
#include "Mediator.h"
#include "Colleage.h"
#include <iostream>
using namespace std;
Colleage::Colleage()
{

}
Colleage::Colleage(Mediator* mdt)
{
    this->_mdt = mdt;
}
Colleage::~Colleage()
{
}
ConcreteColleageA::ConcreteColleageA()
{
}
ConcreteColleageA::~ConcreteColleageA()
{
}
ConcreteColleageA::ConcreteColleageA(Mediator* mdt):Colleage(mdt)
{
}

string ConcreteColleageA::GetState()
{
    return _sdt;
}
void ConcreteColleageA::SetState(const string& sdt)
{
    _sdt = sdt;
}
void ConcreteColleageA::Aciton()
{
    _mdt->DoActionFromAtoB();
    cout<<"State of ConcreteColleageA:"<<" "<<this->GetState()<<endl;
}
ConcreteColleageB::ConcreteColleageB()
{
}
ConcreteColleageB::~ConcreteColleageB()
{
}
ConcreteColleageB::ConcreteColleageB(Mediator* mdt):Colleage(mdt)
{
}
void ConcreteColleageB::Aciton()
{
    _mdt->DoActionFromBtoA();
    cout<<"State of ConcreteColleageB:"<<" "<<this->GetState()<<endl;
}
string ConcreteColleageB::GetState()
{
    return _sdt;
}
void ConcreteColleageB::SetState(const string& sdt)
{
    _sdt = sdt;
}

```

Mediator.h

```c++
//Mediator.h
#ifndef _MEDIATOR_H_
#define _MEDIATOR_H_
class Colleage;
class Mediator {
public:
    virtual ~Mediator();
    virtual void DoActionFromAtoB() = 0;
    virtual void DoActionFromBtoA() = 0;
protected:
    Mediator();
private:
};

class ConcreteMediator:public Mediator {
public:
    ConcreteMediator();
    ConcreteMediator(Colleage* clgA,Colleage* clgB);
    ~ConcreteMediator();
    void SetConcreteColleageA(Colleage* clgA);
    void SetConcreteColleageB(Colleage* clgB);
    Colleage* GetConcreteColleageA();
    Colleage* GetConcreteColleageB();
    void IntroColleage(Colleage* clgA,Colleage* clgB);
    void DoActionFromAtoB();
    void DoActionFromBtoA();
protected:
private:
    Colleage* _clgA;
    Colleage* _clgB;
};
#endif //~_MEDIATOR_H

```

Mediator.cpp

```c++
//Mediator.cpp
#include "Mediator.h"
#include "Colleage.h"
Mediator::Mediator()
{
}
Mediator::~Mediator()
{
}
ConcreteMediator::ConcreteMediator()
{
}
ConcreteMediator::~ConcreteMediator()
{
}
ConcreteMediator::ConcreteMediator(Colleage * clgA,Colleage* clgB)
{
    this->_clgA = clgA;
    this->_clgB = clgB;
}
void ConcreteMediator::DoActionFromAtoB()
{
    _clgB->SetState(_clgA->GetState());
}
void ConcreteMediator::SetConcreteColleageA(Colleage* clgA)
{
    this->_clgA = clgA;
}
void ConcreteMediator::SetConcreteColleageB(Colleage* clgB)
{
    this->_clgB = clgB;
}
Colleage* ConcreteMediator::GetConcreteColleageA()
{
    return _clgA;
}
Colleage* ConcreteMediator::GetConcreteColleageB()
{
    return _clgB;
}
void ConcreteMediator::IntroColleage(Colleage* clgA,Colleage* clgB)
{
    this->_clgA = clgA;
    this->_clgB = clgB;
}
void ConcreteMediator::DoActionFromBtoA()
{
    _clgA->SetState(_clgB->GetState());
}

```

main.cpp

```c++
#include "Mediator.h"
#include "Colleage.h"
#include <iostream>
using namespace std;
int main(int argc,char* argv[])
{
    ConcreteMediator* m = new ConcreteMediator();
    ConcreteColleageA* c1 = new ConcreteColleageA(m);
    ConcreteColleageB* c2 = new ConcreteColleageB(m);
    m->IntroColleage(c1,c2);
    c1->SetState("old");
    c2->SetState("old");
    c1->Aciton();
    c2->Aciton();
    cout<<endl;

    c1->SetState("new");
    c1->Aciton();
    c2->Aciton();
    cout<<endl;

    c2->SetState("old");
    c2->Aciton();
    c1->Aciton();
    return 0;
}
```

Mediator 模式是一种很有用并且很常用的模式，它通过将对象间的通信封装到一个类中，将多对多的通信转化为一对多的通信，降低了系统的复杂性。Mediator 还获得系统解耦的特性，通过 Mediator，各个 Colleague 就不必维护各自通信的对象和通信协议，降低了系统的耦合性，Mediator 和各个 Colleague 就可以相互独立地修改了。 

Mediator 模式还有一个很显著额特点就是将控制集中，集中的优点就是便于管理，也正式符合了 OO 设计中的每个类的职责要单一和集中的原则。  
